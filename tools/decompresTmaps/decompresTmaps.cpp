// decompresTmaps.cpp : Tento soubor obsahuje funkci main. Provádění programu se tam zahajuje a ukončuje.
//

#include <iostream>
#include <cstdint>
#include <cstring>

#define RNC_SIGN 0x524E43 // RNC
#define RNC_HEADER_SIZE 0x12
#define MAX_BUF_SIZE 0x100000

FILE* int32_t_DB73C_tmapsfile;//int32_t_DAF50[0x7ec]
uint8_t* TMAPS00TAB_BEGIN_BUFFER = 0;//2c7ed0
int32_t mylseek(FILE* filedesc, int32_t position, char type) {
	return fseek(filedesc, position, type);
};
int32_t x_lseek(FILE* filedesc, int32_t position, char type) {
	return mylseek(filedesc, position, type);
};
int sub_9891E_seek(FILE* filedecs, int position, char type)//27991e
{
	return x_lseek(filedecs, position, type);
}
// AA7C0: using guessed type int32_t lseek(int32_t, int32_t, char);
size_t x_read(FILE* descriptor, uint8_t* data, uint32_t size) {
	size_t result = fread(data, 1, size, descriptor);
	return result;
};
size_t sub_988A7_read(FILE* a1, uint8_t* a2, int a3)//2798a7
{

	return x_read(a1, a2, a3);
}

typedef struct huftable_s {
	uint32_t l1; // +0
	uint16_t l2; // +4
	uint32_t l3; // +6
	uint16_t bit_depth; // +A
} huftable_t;

typedef struct vars_s {
	uint16_t max_matches;
	uint16_t enc_key;
	uint32_t pack_block_size;
	uint16_t dict_size;
	uint32_t method;
	uint32_t pus_mode;
	uint32_t input_size;
	uint32_t file_size;

	// inner
	uint32_t bytes_left;
	uint32_t packed_size;
	uint32_t processed_size;
	uint32_t v7;
	uint32_t pack_block_pos;
	uint16_t pack_token, bit_count, v11;
	uint16_t last_min_offset;
	uint32_t v17;
	uint32_t pack_block_left_size;
	uint16_t match_count;
	uint16_t match_offset;
	uint32_t v20, v21;
	uint32_t bit_buffer;

	uint32_t unpacked_size;
	uint32_t rnc_data_size;
	uint16_t unpacked_crc, unpacked_crc_real;
	uint16_t packed_crc;
	uint32_t leeway;
	uint32_t chunks_count;

	uint8_t* mem1;
	uint8_t* pack_block_start;
	uint8_t* pack_block_max;
	uint8_t* pack_block_end;
	uint16_t* mem2;
	uint16_t* mem3;
	uint16_t* mem4;
	uint16_t* mem5;

	uint8_t* decoded;
	uint8_t* window;

	size_t read_start_offset, write_start_offset;
	uint8_t* input, * output, * temp;
	size_t input_offset, output_offset, temp_offset;

	uint8_t tmp_crc_data[2048];
	huftable_t raw_table[16];
	huftable_t pos_table[16];
	huftable_t len_table[16];
} vars_t;

#define RNC_SIGN 0x524E43 // RNC
#define RNC_HEADER_SIZE 0x12
#define MAX_BUF_SIZE 0x100000

uint8_t read_byte(uint8_t* buf, size_t* offset)
{
	return buf[(*offset)++];
}

uint16_t read_word_be(uint8_t* buf, size_t* offset)
{
	uint8_t b1 = read_byte(buf, offset);
	uint8_t b2 = read_byte(buf, offset);

	return (b1 << 8) | b2;
}

uint32_t read_dword_be(uint8_t * buf, size_t * offset)
{
	uint16_t w1 = read_word_be(buf, offset);
	uint16_t w2 = read_word_be(buf, offset);

	return (w1 << 16) | w2;
}

static const uint16_t crc_table[] = {
	0x0000, 0xC0C1, 0xC181, 0x0140, 0xC301, 0x03C0, 0x0280, 0xC241,
	0xC601, 0x06C0, 0x0780, 0xC741, 0x0500, 0xC5C1, 0xC481, 0x0440,
	0xCC01, 0x0CC0, 0x0D80, 0xCD41, 0x0F00, 0xCFC1, 0xCE81, 0x0E40,
	0x0A00, 0xCAC1, 0xCB81, 0x0B40, 0xC901, 0x09C0, 0x0880, 0xC841,
	0xD801, 0x18C0, 0x1980, 0xD941, 0x1B00, 0xDBC1, 0xDA81, 0x1A40,
	0x1E00, 0xDEC1, 0xDF81, 0x1F40, 0xDD01, 0x1DC0, 0x1C80, 0xDC41,
	0x1400, 0xD4C1, 0xD581, 0x1540, 0xD701, 0x17C0, 0x1680, 0xD641,
	0xD201, 0x12C0, 0x1380, 0xD341, 0x1100, 0xD1C1, 0xD081, 0x1040,
	0xF001, 0x30C0, 0x3180, 0xF141, 0x3300, 0xF3C1, 0xF281, 0x3240,
	0x3600, 0xF6C1, 0xF781, 0x3740, 0xF501, 0x35C0, 0x3480, 0xF441,
	0x3C00, 0xFCC1, 0xFD81, 0x3D40, 0xFF01, 0x3FC0, 0x3E80, 0xFE41,
	0xFA01, 0x3AC0, 0x3B80, 0xFB41, 0x3900, 0xF9C1, 0xF881, 0x3840,
	0x2800, 0xE8C1, 0xE981, 0x2940, 0xEB01, 0x2BC0, 0x2A80, 0xEA41,
	0xEE01, 0x2EC0, 0x2F80, 0xEF41, 0x2D00, 0xEDC1, 0xEC81, 0x2C40,
	0xE401, 0x24C0, 0x2580, 0xE541, 0x2700, 0xE7C1, 0xE681, 0x2640,
	0x2200, 0xE2C1, 0xE381, 0x2340, 0xE101, 0x21C0, 0x2080, 0xE041,
	0xA001, 0x60C0, 0x6180, 0xA141, 0x6300, 0xA3C1, 0xA281, 0x6240,
	0x6600, 0xA6C1, 0xA781, 0x6740, 0xA501, 0x65C0, 0x6480, 0xA441,
	0x6C00, 0xACC1, 0xAD81, 0x6D40, 0xAF01, 0x6FC0, 0x6E80, 0xAE41,
	0xAA01, 0x6AC0, 0x6B80, 0xAB41, 0x6900, 0xA9C1, 0xA881, 0x6840,
	0x7800, 0xB8C1, 0xB981, 0x7940, 0xBB01, 0x7BC0, 0x7A80, 0xBA41,
	0xBE01, 0x7EC0, 0x7F80, 0xBF41, 0x7D00, 0xBDC1, 0xBC81, 0x7C40,
	0xB401, 0x74C0, 0x7580, 0xB541, 0x7700, 0xB7C1, 0xB681, 0x7640,
	0x7200, 0xB2C1, 0xB381, 0x7340, 0xB101, 0x71C0, 0x7080, 0xB041,
	0x5000, 0x90C1, 0x9181, 0x5140, 0x9301, 0x53C0, 0x5280, 0x9241,
	0x9601, 0x56C0, 0x5780, 0x9741, 0x5500, 0x95C1, 0x9481, 0x5440,
	0x9C01, 0x5CC0, 0x5D80, 0x9D41, 0x5F00, 0x9FC1, 0x9E81, 0x5E40,
	0x5A00, 0x9AC1, 0x9B81, 0x5B40, 0x9901, 0x59C0, 0x5880, 0x9841,
	0x8801, 0x48C0, 0x4980, 0x8941, 0x4B00, 0x8BC1, 0x8A81, 0x4A40,
	0x4E00, 0x8EC1, 0x8F81, 0x4F40, 0x8D01, 0x4DC0, 0x4C80, 0x8C41,
	0x4400, 0x84C1, 0x8581, 0x4540, 0x8701, 0x47C0, 0x4680, 0x8641,
	0x8201, 0x42C0, 0x4380, 0x8341, 0x4100, 0x81C1, 0x8081, 0x4040
};

uint16_t crc_block(uint8_t * buf, size_t offset, int size)
{
	uint16_t crc = 0;

	while (size--)
	{
		crc ^= read_byte(buf, &offset);
		crc = (crc >> 8) ^ crc_table[crc & 0xFF];
	}

	return crc;
}

void read_buf(uint8_t * dest, uint8_t * source, size_t * offset, int size)
{
	memmove(dest, &source[*offset], size);
	*offset += size;
}

uint8_t read_source_byte(vars_t * v)
{
	if (v->pack_block_start == &v->mem1[0xFFFD])
	{
		int left_size = v->file_size - v->input_offset;

		int size_to_read;
		if (left_size <= 0xFFFD)
			size_to_read = left_size;
		else
			size_to_read = 0xFFFD;

		v->pack_block_start = v->mem1;

		read_buf(v->pack_block_start, v->input, &v->input_offset, size_to_read);

		if (left_size - size_to_read > 2)
			left_size = 2;

		read_buf(&v->mem1[size_to_read], v->input, &v->input_offset, left_size);
		v->input_offset -= left_size;
	}

	return *v->pack_block_start++;
}

uint32_t input_bits_m2(vars_t * v, short count)
{
	uint32_t bits = 0;

	while (count--)
	{
		if (!v->bit_count)
		{
			v->bit_buffer = read_source_byte(v);
			v->bit_count = 8;
		}

		bits <<= 1;

		if (v->bit_buffer & 0x80)
			bits |= 1;

		v->bit_buffer <<= 1;
		v->bit_count--;
	}

	return bits;
}



uint32_t input_bits_m1(vars_t * v, short count)
{
	uint32_t bits = 0;
	uint32_t prev_bits = 1;

	while (count--)
	{
		if (!v->bit_count)
		{
			uint8_t b1 = read_source_byte(v);
			uint8_t b2 = read_source_byte(v);
			v->bit_buffer = (v->pack_block_start[1] << 24) | (v->pack_block_start[0] << 16) | (b2 << 8) | b1;

			v->bit_count = 16;
		}

		if (v->bit_buffer & 1)
			bits |= prev_bits;

		v->bit_buffer >>= 1;
		prev_bits <<= 1;
		v->bit_count--;
	}

	return bits;
}

int input_bits(vars_t * v, short count)
{
	if (v->method != 2)
		return input_bits_m1(v, count);
	else
		return input_bits_m2(v, count);
}

void clear_table(huftable_t * data, int count)
{
	for (int i = 0; i < count; ++i)
	{
		data[i].l1 = 0;
		data[i].l2 = 0xFFFF;
		data[i].l3 = 0;
		data[i].bit_depth = 0;
	}
}

uint32_t inverse_bits(uint32_t value, int count)
{
	int i = 0;
	while (count--)
	{
		i <<= 1;

		if (value & 1)
			i |= 1;

		value >>= 1;
	}

	return i;
}

void proc_20(huftable_t * data, int count)
{
	int val = 0;
	uint32_t div = 0x80000000;
	int bits_count = 1;

	while (bits_count <= 16)
	{
		int i = 0;

		while (1)
		{
			if (i >= count)
			{
				bits_count++;
				div >>= 1;
				break;
			}

			if (data[i].bit_depth == bits_count)
			{
				data[i].l3 = inverse_bits(val / div, bits_count);
				val += div;
			}

			i++;
		}
	}
}

void make_huftable(vars_t * v, huftable_t * data, int count)
{
	clear_table(data, count);

	int leaf_nodes = input_bits_m1(v, 5);

	if (leaf_nodes)
	{
		if (leaf_nodes > 16)
			leaf_nodes = 16;

		for (int i = 0; i < leaf_nodes; ++i)
			data[i].bit_depth = input_bits_m1(v, 4);

		proc_20(data, leaf_nodes);
	}
}

uint32_t decode_table_data(vars_t * v, huftable_t * data)
{
	uint32_t i = 0;

	while (1)
	{
		if (data[i].bit_depth && (data[i].l3 == (v->bit_buffer & ((1 << data[i].bit_depth) - 1))))
		{
			input_bits_m1(v, data[i].bit_depth);

			if (i < 2)
				return i;

			return input_bits_m1(v, i - 1) | (1 << (i - 1));
		}

		i++;
	}
}

void write_buf(uint8_t * dest, size_t * offset, uint8_t * source, int size)
{
	memmove(&dest[*offset], source, size);
	*offset += size;
}

void write_decoded_byte(vars_t * v, uint8_t b)
{
	if (&v->decoded[0xFFFF] == v->window)
	{
		write_buf(v->output, &v->output_offset, &v->decoded[v->dict_size], 0xFFFF - v->dict_size);
		memmove(v->decoded, &v->window[-v->dict_size], v->dict_size);
		v->window = &v->decoded[v->dict_size];
	}

	*v->window++ = b;
	v->unpacked_crc_real = crc_table[(v->unpacked_crc_real ^ b) & 0xFF] ^ (v->unpacked_crc_real >> 8);
}

void ror_w(uint16_t * x)
{
	if (*x & 1)
		* x = 0x8000 | (*x >> 1);
	else
		*x >>= 1;
}

int unpack_data_m1(vars_t * v)
{
	while (v->processed_size < v->input_size)
	{
		make_huftable(v, v->raw_table, sizeof(v->raw_table));
		make_huftable(v, v->len_table, sizeof(v->len_table));
		make_huftable(v, v->pos_table, sizeof(v->pos_table));

		int subchunks = input_bits_m1(v, 16);

		while (subchunks--)
		{
			uint32_t data_length = decode_table_data(v, v->raw_table);
			v->processed_size += data_length;

			if (data_length)
			{
				while (data_length--)
					write_decoded_byte(v, (v->enc_key ^ read_source_byte(v)) & 0xFF);

				ror_w(&v->enc_key);

				v->bit_buffer = (((v->pack_block_start[2] << 16) | (v->pack_block_start[1] << 8) | v->pack_block_start[0]) << v->bit_count) | (v->bit_buffer & ((1 << v->bit_count) - 1));
			}

			if (subchunks)
			{
				v->match_offset = decode_table_data(v, v->len_table) + 1;
				v->match_count = decode_table_data(v, v->pos_table) + 2;
				v->processed_size += v->match_count;

				while (v->match_count--)
					write_decoded_byte(v, v->window[-v->match_offset]);
			}
		}
	}

	write_buf(v->output, &v->output_offset, &v->decoded[v->dict_size], v->window - &v->decoded[v->dict_size]);
	return 0;
}

void decode_match_count(vars_t * v)
{
	v->match_count = input_bits_m2(v, 1) + 4;

	if (input_bits_m2(v, 1))
		v->match_count = ((v->match_count - 1) << 1) + input_bits_m2(v, 1);
}

void decode_match_offset(vars_t * v)
{
	v->match_offset = 0;
	if (input_bits_m2(v, 1))
	{
		v->match_offset = input_bits_m2(v, 1);

		if (input_bits_m2(v, 1))
		{
			v->match_offset = ((v->match_offset << 1) | input_bits_m2(v, 1)) | 4;

			if (!input_bits_m2(v, 1))
				v->match_offset = (v->match_offset << 1) | input_bits_m2(v, 1);
		}
		else if (!v->match_offset)
			v->match_offset = input_bits_m2(v, 1) + 2;
	}

	v->match_offset = ((v->match_offset << 8) | read_source_byte(v)) + 1;
}

int unpack_data_m2(vars_t * v)
{
	while (v->processed_size < v->input_size)
	{
		while (1)
		{
			if (!input_bits_m2(v, 1))
			{
				write_decoded_byte(v, (v->enc_key ^ read_source_byte(v)) & 0xFF);

				ror_w(&v->enc_key);

				v->processed_size++;
			}
			else
			{
				if (input_bits_m2(v, 1))
				{
					if (input_bits_m2(v, 1))
					{
						if (input_bits_m2(v, 1))
						{
							v->match_count = read_source_byte(v) + 8;

							if (v->match_count == 8)
							{
								input_bits_m2(v, 1);
								break;
							}
						}
						else
							v->match_count = 3;

						decode_match_offset(v);
					}
					else
					{
						v->match_count = 2;
						v->match_offset = read_source_byte(v) + 1;
					}

					v->processed_size += v->match_count;

					while (v->match_count--)
						write_decoded_byte(v, v->window[-v->match_offset]);
				}
				else
				{
					decode_match_count(v);

					if (v->match_count != 9)
					{
						decode_match_offset(v);
						v->processed_size += v->match_count;

						while (v->match_count--)
							write_decoded_byte(v, v->window[-v->match_offset]);
					}
					else
					{
						uint32_t data_length = (input_bits_m2(v, 4) << 2) + 12;
						v->processed_size += data_length;

						while (data_length--)
							write_decoded_byte(v, (v->enc_key ^ read_source_byte(v)) & 0xFF);

						ror_w(&v->enc_key);
					}
				}
			}
		}
	}

	write_buf(v->output, &v->output_offset, &v->decoded[v->dict_size], v->window - &v->decoded[v->dict_size]);
	return 0;
}

int do_unpack_data(vars_t* v)
{
	int start_pos = v->input_offset;

	uint32_t sign = read_dword_be(v->input, &v->input_offset);
	if ((sign >> 8) != RNC_SIGN)
		return 6;

	v->method = sign & 3;
	v->input_size = read_dword_be(v->input, &v->input_offset);
	v->packed_size = read_dword_be(v->input, &v->input_offset);
	if (v->file_size < v->packed_size)
		return 7;
	v->unpacked_crc = read_word_be(v->input, &v->input_offset);
	v->packed_crc = read_word_be(v->input, &v->input_offset);

	/*v->leeway = */read_byte(v->input, &v->input_offset);
	/*v->chunks_count = */read_byte(v->input, &v->input_offset);

	if (crc_block(v->input, v->input_offset, v->packed_size) != v->packed_crc)
		return 4;

	v->mem1 = (uint8_t*)malloc(0xFFFF);
	v->decoded = (uint8_t*)malloc(0xFFFF);
	v->pack_block_start = &v->mem1[0xFFFD];
	v->window = &v->decoded[v->dict_size];

	v->unpacked_crc_real = 0;
	v->bit_count = 0;
	v->bit_buffer = 0;
	v->processed_size = 0;

	uint16_t specified_key = v->enc_key;

	int error_code = 0;
	if (input_bits(v, 1) && !v->pus_mode)
		error_code = 9;

	if (!error_code)
	{
		if (input_bits(v, 1) && !v->enc_key) // key is needed, but not specified as argument
			error_code = 10;
	}

	if (!error_code)
	{
		switch (v->method)
		{
		case 1: error_code = unpack_data_m1(v); break;
		case 2: error_code = unpack_data_m2(v); break;
		}
	}

	v->enc_key = specified_key;

	free(v->mem1);
	free(v->decoded);

	v->input_offset = start_pos + v->packed_size + RNC_HEADER_SIZE;

	if (error_code)
		return error_code;

	if (v->unpacked_crc != v->unpacked_crc_real)
		return 5;

	return 0;
}

int do_unpack(vars_t* v)
{
	v->packed_size = v->file_size;

	if (v->file_size < RNC_HEADER_SIZE)
		return 6;

	int result = do_unpack_data(v); // data
	if (result == 0)return v->input_size;
	return -result;
}

vars_t* init_vars()
{
	vars_t* v = (vars_t*)malloc(sizeof(vars_t));
	v->enc_key = 0;
	v->max_matches = 0x1000;
	v->unpacked_crc_real = 0;
	v->pack_block_size = 0x3000;
	v->dict_size = 0xFFFF;
	v->method = 1;
	v->pus_mode = 0;

	v->read_start_offset = 0;
	v->write_start_offset = 0;
	v->input_offset = 0;
	v->output_offset = 0;
	v->temp_offset = 0;

	memset(v->tmp_crc_data, 0, sizeof(v->tmp_crc_data));
	memset(v->raw_table, 0, sizeof(v->raw_table));
	memset(v->pos_table, 0, sizeof(v->pos_table));
	memset(v->len_table, 0, sizeof(v->len_table));

	return v;
}

int sub_9894C_decompress(uint8_t* a1, uint8_t* a2) {
	vars_t* v = init_vars();
	if (v->method == 1)
	{
		if (v->dict_size > 0x8000)
			v->dict_size = 0x8000;
		v->max_matches = 0x1000;
	}
	else if (v->method == 2)
	{
		if (v->dict_size > 0x1000)
			v->dict_size = 0x1000;
		v->max_matches = 0xFF;
	}

	v->file_size = MAX_BUF_SIZE;
	v->input = (uint8_t*)malloc(MAX_BUF_SIZE);

	uint32_t signature = a1[0] + (a1[1] << 8) + (a1[2] << 16);
	if (signature == 0x434e52)
	{
		uint32_t inputsize = a1[11] + (a1[10] << 8) + (a1[9] << 16) + (a1[8] << 24);
		memmove(v->input, a1, inputsize + 0x12);
	}
	else
	{
		v->input[0] = 0;
	}
	//v->input = a1;

	v->output = a2;
	v->temp = (uint8_t*)malloc(MAX_BUF_SIZE);

	int error_code = 0;
	/*switch (v->pus_mode)
	{
	case 0: error_code = do_pack(v); break;
	case 1: error_code = do_unpack(v); break;
	case 2: error_code = do_search(v); break;
	}*/
	error_code = do_unpack(v);

	if (v->pus_mode == 2)
	{
		free(v->input);
		free(v->output);
		free(v->temp);
		free(v->input);
		free(v);

		return error_code;
	}

	/*if (error_code)
	 {
		switch (error_code) {
		case 4: printf("Corrupted input data.\n"); break;
		case 5: printf("CRC check failed.\n"); break;
		case 6:
		case 7:
			printf("Wrong RNC header.\n"); break;
		case 10: printf("No RNC archives were found.\n"); break;
		default: printf("Cannot process file. Error code: %x\n", error_code); break;
		}
	}*/

	//free(v->input);
	//free(v->output);
	free(v->temp);
	free(v);
	if (error_code == -6)return 0;
	//if (error_code == 0)return 0;
	return error_code;
}
int sub_70C60_decompress_tmap(uint16_t a1, uint8_t* a2)//251c60
{
	//int v2; // edi
	int v3; // ebx
	int result; // eax

	if (int32_t_DB73C_tmapsfile == NULL)
		return (int)int32_t_DB73C_tmapsfile;
	//v2 = 10 * a1;
	sub_9891E_seek(int32_t_DB73C_tmapsfile, *(int32_t*)(10 * a1 + TMAPS00TAB_BEGIN_BUFFER + 4), 0);//lseek
	v3 = *(uint32_t*)& TMAPS00TAB_BEGIN_BUFFER[10 * (a1 + 1) + 4] - *(uint32_t*)& TMAPS00TAB_BEGIN_BUFFER[10 * a1 + 4];
	if (sub_988A7_read(int32_t_DB73C_tmapsfile, a2, v3) != v3)
		return -1;
	result = sub_9894C_decompress(a2, a2);
	if (result >= 0)
	{
		if (!result)
			result = v3;
	}
	else
	{
		printf("ERROR decompressing tmap%03d\n", *a2);
		result = -2;
	}
	return result;
}

int32_t sub_71CD0(int a1)//252cd0
{
	int i; // edx

	for (i = 0; (int16_t)i < (int32_t) * (uint16_t*)(a1 + 22); i++)
	{
		if (!*(int32_t*)(14 * (int16_t)i + *(int32_t*)(a1 + 8) + 4))
			return i;
	}
	return -1;
}

int sub_71E70(int a1, uint32_t a2, int16_t a3)//252e70
{
	int16_t v3; // si
	int16_t v4; // ax
	int16_t v5; // dx
	int v6; // ecx
	int v7; // eax
	int result; // eax

	v3 = -1;
	if (a2 < *(int32_t*)(a1 + 4))
	{
		v4 = sub_71CD0(a1);
		v5 = v4;
		v6 = v4;
		v3 = v4;
		if (v4 > -1)
		{
			v7 = 14 * v4;
			*(int16_t*)(*(int32_t*)(a1 + 8) + v7 + 10) = v5;
			*(int32_t*)(*(int32_t*)(a1 + 8) + v7 + 4) = a2;
			*(int32_t*)(*(int32_t*)(a1 + 8) + v7) = *(int32_t*)a1 + *(int32_t*)(a1 + 16) - *(int32_t*)(a1 + 4);
			*(int16_t*)(*(int32_t*)(a1 + 8) + v7 + 12) = a3;
			*(int32_t*)(a1 + 4) -= a2;
			*(int16_t*)(*(int32_t*)(a1 + 8) + v7 + 8) = *(int16_t*)(a1 + 20);
			*(int32_t*)(*(int32_t*)(a1 + 12) + 4 * (uint16_t)(*(int16_t*)(a1 + 20))++) = *(int32_t*)(a1 + 8) + 14 * v6;
		}
	}
	if (v3 <= -1)
		result = 0;
	else
		result = 14 * v3 + *(int32_t*)(a1 + 8);
	return result;
}

int int32_t_F66F0[504]; // idb//2c76f0
int int32_t_F5730[504]; // idb
int int32_t_F5F10[504]; // idb
int int32_t_E9C28; // weak
int int32_t_E9C08; // weak

int sub_721C0(uint16_t* a1, int* a2, int16_t a3)//2531c0
{
	int16_t v3; // cx
	int16_t v4; // si
	int16_t i; // bx
	int32_t* v6; // edx
	int v7; // ebx
	int v8; // ecx
	int16_t v9; // ST08_2
	int v10; // edx
	int16_t v12; // [esp+Ch] [ebp-4h]

	v3 = -1;
	v4 = -1;
	if (!*a1)
		return 0;
	for (i = 0; i < (int32_t)* a1; i++)
	{
		v6 = (int32_t*)(28 * i + *(int32_t*)(a1 + 1));
		if (v6[1])
		{
			if (!*v6)
				v4 = i;
		}
		else
		{
			v3 = i;
		}
	}
	v12 = v3 <= 0 ? v4 : v3;
	if (v12 <= -1)
		return 0;
	v7 = *a2;
	v8 = *(uint16_t*)(*a2 + 4) * *(uint16_t*)(*a2 + 2);
	v9 = *(int16_t*)(v8 + *a2 + 6);
	v10 = 28 * v12;
	*(int32_t*)(v10 + *(int32_t*)(a1 + 1) + 4) = (int32_t)a2;
	*(int16_t*)(v10 + *(int32_t*)(a1 + 1) + 12) = 6;
	*(int16_t*)(v10 + *(int32_t*)(a1 + 1) + 14) = v8 + 6;
	*(int16_t*)(v10 + *(int32_t*)(a1 + 1) + 16) = v9;
	*(int16_t*)(v10 + *(int32_t*)(a1 + 1) + 18) = *(int16_t*)(v7 + 2);
	*(int16_t*)(v10 + *(int32_t*)(a1 + 1) + 20) = *(int16_t*)(v7 + 4);
	*(int32_t*)(v10 + *(int32_t*)(a1 + 1) + 8) = v8 + 6;
	*(int16_t*)(v10 + *(int32_t*)(a1 + 1) + 22) = 1;
	*(int32_t*)(v10 + *(int32_t*)(a1 + 1)) = 1;
	*(int16_t*)(v10 + *(int32_t*)(a1 + 1) + 24) = v12;
	*(int16_t*)(v10 + *(int32_t*)(a1 + 1) + 26) = a3;
	return v10 + *(int32_t*)(a1 + 1);
}

void sub_70F50(uint16_t a1)//251f50
{
	int index; // eax
	uint16_t v2; // bx
	uint16_t i; // si
	int v4; // edi
	int v5; // [esp+0h] [ebp-Ch]
	int v6; // [esp+8h] [ebp-4h]

	v5 = 0;// x_D41A0_BYTEARRAY_4_struct.byteindex_26;
	//index = (int)TMAPS00TAB_BEGIN_BUFFER;
	v2 = *(int16_t*)(10 * a1 + TMAPS00TAB_BEGIN_BUFFER + 8);
	for (i = *(int16_t*)(10 * a1 + TMAPS00TAB_BEGIN_BUFFER + 8); i < 0x1F8u; i++)
	{
		index = 10 * i + (int)TMAPS00TAB_BEGIN_BUFFER;
		if (v2 != *(int16_t*)(index + 8))
			break;
		v6 = i;
		if (!int32_t_F66F0[i])
		{
			index = sub_71E70(int32_t_E9C28, (uint16_t)(4 * ((uint32_t)(*(int32_t*)index + 13) >> 2)), i);
			v4 = index;
			if (index)
			{
				index = sub_70C60_decompress_tmap(i, *(uint8_t * *)index);
				if (index != -1)
				{
					int32_t_F5F10[v6] = v4;
					int32_t_F66F0[v6] = v4;
					int32_t_F5730[v6] = v5;
					index = int32_t_F66F0[v6];
					if (**(int8_t * *)index & 1)
						index = sub_721C0((uint16_t*)int32_t_E9C08, (int*)index, i);
					if (v2 < 0x1E0u)
					{
						if (v2 != 311)
							continue;
					LABEL_14:
						index = *(int32_t*)int32_t_F66F0[i];
						*(int8_t*)index |= 0x20u;
						continue;
					}
					if (v2 <= 0x1E0u || v2 >= 0x1E8u && (v2 <= 0x1E8u || v2 == 496))
						goto LABEL_14;
				}
			}
		}
	}
	//	return result;
}

char printbuffer[512];
FILE* int32_t_DB740_tmaps00file;//int32_t_DAF50[0x7f0]
FILE* int32_t_DB744_tmaps10file;//int32_t_DAF50[0x7f4]
FILE* int32_t_DB748_tmaps20file;//int32_t_DAF50[0x7f8]
int myclose(FILE* descriptor) {
	return fclose(descriptor);
};
FILE* mycreate(char* path, uint32_t flags) {
	FILE* fp;
	char path2[512] = "\0";
	//pathfix(path, path2);//only for DOSBOX version
	//fp = fopen(path2, "wb+");
	fopen_s(&fp,path, "wb+");
	return fp;
};
FILE* x_creat(char* path, uint32_t flags) {
	return mycreate(path, flags);
	/*FILE *fp;
	char path2[512] = "\0";
	pathfix(path, path2);//only for DOSBOX version
	fp = fopen(path2, "wb+");
	return fp;*/
};// weak
int x_close(FILE* descriptor) {
	return myclose(descriptor);
};
FILE* myopen(char* path, int pmode, uint32_t flags) {
	//bool localDrive::FileOpen(DOS_File * * file, const char * name, uint32_t flags) {
	const char* type;
	if ((pmode == 0x222) && (flags == 0x40))type = "rb+";
	else if ((pmode == 0x200) && (flags == 0x40))type = "rb+";
	else
		exit(1);//error - DOSSetError(DOSERR_ACCESS_CODE_INVALID);
	FILE * fp;
	char path2[512] = "\0";
	//pathfix(path, path2);//only for DOSBOX version
	//if(file_exists(path2))

	fopen_s(&fp, path, type);
	return fp;
};
FILE* x_sopen(char* path, int pmode, uint32_t flags) {
	return myopen(path, pmode, flags);
};
FILE* sub_98817_open(char* pathname, int __pmode)//279817
{
	FILE* file; // ST10_4


	if (__pmode == 0x222)
	{
		file = x_creat(pathname, 0x1c0);
		//x_setmode(v2, 0x200);
		x_close(file);
	}
	return x_sopen(pathname, __pmode, 0x40);
}
int sub_98882_close(FILE* a1)//279882
{
	return x_close(a1);
}

void sub_70A60_open_tmaps()//251a60
{
	//char printbuffer[512];//char v1; // [esp+0h] [ebp-40h]

	sprintf_s(printbuffer, 512, "%s%s/%s/%s.dat", "c:/prenos/Magic2/mc2-orig", "/netherw", "cdata", "tmaps0-0");
	int32_t_DB740_tmaps00file = sub_98817_open(printbuffer, 512);
	if (int32_t_DB740_tmaps00file == NULL)
	{
		sprintf_s(printbuffer, 512, "data/%s.dat", "tmaps0-0");
		int32_t_DB740_tmaps00file = sub_98817_open(printbuffer, 512);
	}
	sprintf_s(printbuffer, 512, "%s%s/%s/%s.dat", "c:/prenos/Magic2/mc2-orig", "/netherw", "cdata", "tmaps1-0");
	int32_t_DB744_tmaps10file = sub_98817_open(printbuffer, 512);
	if (int32_t_DB744_tmaps10file == NULL)
	{
		sprintf_s(printbuffer, 512, "data/%s.dat", "tmaps1-0");
		int32_t_DB744_tmaps10file = sub_98817_open(printbuffer, 512);
	}
	sprintf_s(printbuffer, 512, "%s%s/%s/%s.dat", "c:/prenos/Magic2/mc2-orig", "/netherw", "cdata", "tmaps2-0");
	int32_t_DB748_tmaps20file = sub_98817_open(printbuffer, 512);
	if (int32_t_DB748_tmaps20file == NULL)
	{
		sprintf_s(printbuffer, 512, "data/%s.dat", "tmaps2-0");
		int32_t_DB748_tmaps20file = sub_98817_open(printbuffer, 512);
	}
	int32_t_DB73C_tmapsfile = int32_t_DB740_tmaps00file;
	//return 1;
}

uint16_t int16_t_D951C[0x980] = {//2aa51c
0x0008, 0x212C, 0x002A, 0x0000, 0x00FA, 0x0100, 0x0000,
0x000B, 0x212C, 0x002A, 0x0000, 0x00FA, 0x0100, 0x0000,
0x0000, 0x212C, 0x002A, 0x0000, 0x0096, 0x0100, 0x0000,
0x000E, 0x212C, 0x002A, 0x0000, 0x0096, 0x0100, 0x0000,
0x000E, 0x212C, 0x002A, 0x0000, 0x0096, 0x0100, 0x0000,
0x000E, 0x212C, 0x002A, 0x0000, 0x0096, 0x0100, 0x0000,
0x000E, 0x212C, 0x002A, 0x0000, 0x0096, 0x0100, 0x0000,
0x0026, 0x212C, 0x002A, 0x0000, 0x00FA, 0xFF00, 0x0000,
0x003C, 0x212C, 0x002A, 0x0000, 0x0096, 0xFF00, 0x0000,
0x003F, 0x212C, 0x002A, 0x0000, 0x0032, 0x0102, 0x0000,
0x003F, 0x212C, 0x002A, 0x0000, 0x0064, 0x0102, 0x0000,
0x003F, 0x212C, 0x002A, 0x0000, 0x0096, 0x0102, 0x0000,
0x003F, 0x212C, 0x002A, 0x0000, 0x00C8, 0x0102, 0x0000,
0x003F, 0x212C, 0x002A, 0x0000, 0x00FA, 0x0102, 0x0000,
0x003F, 0x212C, 0x002A, 0x0000, 0x012C, 0x0102, 0x0000,
0x003F, 0x212C, 0x002A, 0x0000, 0x015E, 0x0102, 0x0000,
0x003F, 0x212C, 0x002A, 0x0000, 0x0190, 0x0102, 0x0000,
0x0000, 0x212C, 0x002A, 0x0000, 0x0096, 0x0100, 0x0000,
0x003D, 0x212C, 0x002A, 0x0000, 0x0096, 0x0100, 0x0000,
0x0038, 0x212C, 0x002A, 0x0000, 0x0096, 0xFF00, 0x0000,
0x0038, 0x212C, 0x002A, 0x0000, 0x00A5, 0x0100, 0x0000,
0x0038, 0x212C, 0x002A, 0x0000, 0x00B9, 0x0100, 0x0000,
0x0038, 0x212C, 0x002A, 0x0000, 0x00C8, 0x0100, 0x0000,
0x0038, 0x212C, 0x002A, 0x0000, 0x00D2, 0x0100, 0x0000,
0x0038, 0x212C, 0x002A, 0x0000, 0x00D2, 0x0100, 0x0000,
0x0038, 0x212C, 0x002A, 0x0000, 0x00C8, 0x0100, 0x0000,
0x0038, 0x212C, 0x002A, 0x0000, 0x00BE, 0x0100, 0x0000,
0x0038, 0x212C, 0x002A, 0x0000, 0x00AA, 0x0100, 0x0000,
0x0038, 0x212C, 0x002A, 0x0000, 0x00A0, 0x0100, 0x0000,
0x0038, 0x212C, 0x002A, 0x0000, 0x0096, 0x0100, 0x0000,
0x0038, 0x212C, 0x002A, 0x0000, 0x0082, 0x0100, 0x0000,
0x0038, 0x212C, 0x002A, 0x0000, 0x006E, 0x0100, 0x0000,
0x0038, 0x212C, 0x002A, 0x0000, 0x005A, 0x0100, 0x0000,
0x0038, 0x212C, 0x002A, 0x0000, 0x0046, 0x0100, 0x0000,
0x0038, 0x212C, 0x002A, 0x0000, 0x003C, 0x0100, 0x0000,
0x004C, 0x212C, 0x002A, 0x0000, 0x0320, 0x0300, 0x0000,
0x0000, 0x212C, 0x002A, 0x0000, 0x0096, 0x0100, 0x0000,
0x0000, 0x212C, 0x002A, 0x0000, 0x0096, 0x0100, 0x0000,
0x0000, 0x212C, 0x002A, 0x0000, 0x0096, 0x0100, 0x0000,
0x004F, 0x212C, 0x002A, 0x0000, 0x0190, 0x0100, 0x0000,
0x0016, 0x212C, 0x002A, 0x0000, 0x0118, 0x0100, 0x0000,
0x0036, 0x212C, 0x002A, 0x0000, 0x00FA, 0xFF00, 0x0000,
0x0037, 0x212C, 0x002A, 0x0000, 0x0082, 0xFF00, 0x0000,
0x0052, 0x212C, 0x002A, 0x0000, 0x0096, 0xFF00, 0x0000,
0x0000, 0x212C, 0x002A, 0x0000, 0x00C8, 0xFF00, 0x0000,
0x003E, 0x212C, 0x002A, 0x0000, 0x0096, 0xFF00, 0x0000,
0x0000, 0x212C, 0x002A, 0x0000, 0x0096, 0x0100, 0x0000,
0x0000, 0x212C, 0x002A, 0x0000, 0x012C, 0x0100, 0x0000,
0x0000, 0x212C, 0x002A, 0x0000, 0x0064, 0x0100, 0x0000, 0x0000,
0x212C, 0x002A, 0x0000, 0x012C, 0x0100, 0x0000, 0x0000, 0x212C,
0x002A, 0x0000, 0x0064, 0x0100, 0x0000, 0x0041, 0x212C, 0x002A,
0x0000, 0x0096, 0xFF00, 0x0000, 0x003A, 0x212C, 0x002A, 0x0000,
0x0032, 0xFF00, 0x0000, 0x003A, 0x212C, 0x002A, 0x0000, 0x0064,
0x0100, 0x0000, 0x003A, 0x212C, 0x002A, 0x0000, 0x0096, 0x0100,
0x0000, 0x003A, 0x212C, 0x002A, 0x0000, 0x00C8, 0x0100, 0x0000,
0x003A, 0x212C, 0x002A, 0x0000, 0x00FA, 0x0100, 0x0000, 0x003A,
0x212C, 0x002A, 0x0000, 0x012C, 0x0100, 0x0000, 0x003A, 0x212C,
0x002A, 0x0000, 0x015E, 0x0100, 0x0000, 0x003A, 0x212C, 0x002A,
0x0000, 0x0190, 0x0100, 0x0000, 0x0053, 0x212C, 0x002A, 0x0000,
0x0320, 0x0400, 0x0000, 0x0054, 0x212C, 0x002A, 0x0000, 0x0320,
0x0400, 0x0000, 0x0000, 0x212C, 0x002A, 0x0000, 0x0096, 0x0100,
0x0000, 0x0000, 0x212C, 0x002A, 0x0000, 0x0064, 0x0100, 0x0000,
0x0000, 0x212C, 0x002A, 0x0000, 0x0096, 0x0100, 0x0000, 0x0051,
0x212C, 0x002A, 0x0000, 0x00C8, 0xFF00, 0x0000, 0x0050, 0x212C,
0x002A, 0x0000, 0x00C8, 0x0100, 0x0000, 0x0039, 0x212C, 0x002A,
0x0000, 0x0032, 0xFF02, 0x0000, 0x0039, 0x212C, 0x002A, 0x0000,
0x0064, 0x0102, 0x0000, 0x0039, 0x212C, 0x002A, 0x0000, 0x0096,
0x0102, 0x0000, 0x0039, 0x212C, 0x002A, 0x0000, 0x00C8, 0x0102,
0x0000, 0x0039, 0x212C, 0x002A, 0x0000, 0x00FA, 0x0102, 0x0000,
0x0039, 0x212C, 0x002A, 0x0000, 0x012C, 0x0102, 0x0000, 0x0039,
0x212C, 0x002A, 0x0000, 0x015E, 0x0102, 0x0000, 0x0039, 0x212C,
0x002A, 0x0000, 0x0190, 0x0102, 0x0000, 0x0000, 0x212C, 0x002A,
0x0000, 0x0096, 0x0100, 0x0000, 0x0040, 0x212C, 0x002A, 0x0000,
0x015E, 0x0100, 0x0000, 0x003B, 0x212C, 0x002A, 0x0000, 0x0096,
0xFF00, 0x0000, 0x0000, 0x212C, 0x002A, 0x0000, 0x0096, 0x0103,
0x0000, 0x004E, 0x212C, 0x002A, 0x0000, 0x01F4, 0xFF00, 0x0000,
0x0056, 0x212C, 0x002A, 0x0000, 0x0096, 0xFF00, 0x0000, 0x0055,
0x212C, 0x002A, 0x0000, 0x0096, 0xFF00, 0x0000, 0x0000, 0x212C,
0x002A, 0x0000, 0x0096, 0x0100, 0x0000, 0x004B, 0x212C, 0x002A,
0x0000, 0x0320, 0x0400, 0x0000, 0x0057, 0x212C, 0x002A, 0x0000,
0x0320, 0x0400, 0x0000, 0x0000, 0x212C, 0x002A, 0x0000, 0x00FA,
0x0100, 0x0000, 0x0000, 0x212C, 0x002A, 0x0000, 0x0064, 0x0100,
0x0000, 0x001E, 0x212C, 0x002A, 0x0000, 0x0096, 0x0100, 0x0000,
0x001E, 0x212C, 0x002A, 0x0000, 0x00B4, 0x0100, 0x0000, 0x0042,
0x212C, 0x002A, 0x0000, 0x0096, 0x0100, 0x0000, 0x0042, 0x212C,
0x002A, 0x0000, 0x00A5, 0x0100, 0x0000, 0x0042, 0x212C, 0x002A,
0x0000, 0x00B9, 0x0100, 0x0000, 0x0042, 0x212C, 0x002A, 0x0000,
0x00C8, 0x0100, 0x0000, 0x0042, 0x212C, 0x002A, 0x0000, 0x00D2,
0x0100, 0x0000, 0x0042, 0x212C, 0x002A, 0x0000, 0x00D2, 0x0100,
0x0000, 0x0042, 0x212C, 0x002A, 0x0000, 0x00C8, 0x0100, 0x0000,
0x0042, 0x212C, 0x002A, 0x0000, 0x00BE, 0x0100, 0x0000, 0x0042,
0x212C, 0x002A, 0x0000, 0x00AA, 0x0100, 0x0000, 0x0042, 0x212C,
0x002A, 0x0000, 0x00A0, 0x0100, 0x0000, 0x0042, 0x212C, 0x002A,
0x0000, 0x0096, 0x0100, 0x0000, 0x0042, 0x212C, 0x002A, 0x0000,
0x0082, 0x0100, 0x0000, 0x0042, 0x212C, 0x002A, 0x0000, 0x006E,
0x0100, 0x0000, 0x0042, 0x212C, 0x002A, 0x0000, 0x005A, 0x0100,
0x0000, 0x0042, 0x212C, 0x002A, 0x0000, 0x0046, 0x0100, 0x0000,
0x0042, 0x212C, 0x002A, 0x0000, 0x003C, 0x0100, 0x0000, 0x0043,
0x212C, 0x002A, 0x0000, 0x0032, 0xFF00, 0x0000, 0x0043, 0x212C,
0x002A, 0x0000, 0x0064, 0x0100, 0x0000, 0x0043, 0x212C, 0x002A,
0x0000, 0x0096, 0x0100, 0x0000, 0x0043, 0x212C, 0x002A, 0x0000,
0x00C8, 0x0100, 0x0000, 0x0043, 0x212C, 0x002A, 0x0000, 0x00FA,
0x0100, 0x0000, 0x0043, 0x212C, 0x002A, 0x0000, 0x012C, 0x0100,
0x0000, 0x0043, 0x212C, 0x002A, 0x0000, 0x015E, 0x0100, 0x0000,
0x0043, 0x212C, 0x002A, 0x0000, 0x0190, 0x0100, 0x0000, 0x0044,
0x212C, 0x002A, 0x0000, 0x0032, 0xFF00, 0x0000, 0x0044, 0x212C,
0x002A, 0x0000, 0x0064, 0x0100, 0x0000, 0x0044, 0x212C, 0x002A,
0x0000, 0x0096, 0x0100, 0x0000, 0x0044, 0x212C, 0x002A, 0x0000,
0x00C8, 0x0100, 0x0000, 0x0044, 0x212C, 0x002A, 0x0000, 0x00FA,
0x0100, 0x0000, 0x0044, 0x212C, 0x002A, 0x0000, 0x012C, 0x0100,
0x0000, 0x0044, 0x212C, 0x002A, 0x0000, 0x015E, 0x0100, 0x0000,
0x0044, 0x212C, 0x002A, 0x0000, 0x0190, 0x0100, 0x0000, 0x0045,
0x212C, 0x002A, 0x0000, 0x0032, 0xFF00, 0x0000, 0x0045, 0x212C,
0x002A, 0x0000, 0x0064, 0x0100, 0x0000, 0x0045, 0x212C, 0x002A,
0x0000, 0x0096, 0x0100, 0x0000, 0x0045, 0x212C, 0x002A, 0x0000,
0x00C8, 0x0100, 0x0000, 0x0045, 0x212C, 0x002A, 0x0000, 0x00FA,
0x0100, 0x0000, 0x0045, 0x212C, 0x002A, 0x0000, 0x012C, 0x0100,
0x0000, 0x0045, 0x212C, 0x002A, 0x0000, 0x015E, 0x0100, 0x0000,
0x0045, 0x212C, 0x002A, 0x0000, 0x0190, 0x0100, 0x0000, 0x0046,
0x212C, 0x002A, 0x0000, 0x0032, 0xFF00, 0x0000, 0x0046, 0x212C,
0x002A, 0x0000, 0x0064, 0x0100, 0x0000, 0x0046, 0x212C, 0x002A,
0x0000, 0x0096, 0x0100, 0x0000, 0x0046, 0x212C, 0x002A, 0x0000,
0x00C8, 0x0100, 0x0000, 0x0046, 0x212C, 0x002A, 0x0000, 0x00FA,
0x0100, 0x0000, 0x0046, 0x212C, 0x002A, 0x0000, 0x012C, 0x0100,
0x0000, 0x0046, 0x212C, 0x002A, 0x0000, 0x015E, 0x0100, 0x0000,
0x0046, 0x212C, 0x002A, 0x0000, 0x0190, 0x0100, 0x0000, 0x0047,
0x212C, 0x002A, 0x0000, 0x0032, 0xFF00, 0x0000, 0x0047, 0x212C,
0x002A, 0x0000, 0x0064, 0x0100, 0x0000, 0x0047, 0x212C, 0x002A,
0x0000, 0x0096, 0x0100, 0x0000, 0x0047, 0x212C, 0x002A, 0x0000,
0x00C8, 0x0100, 0x0000, 0x0047, 0x212C, 0x002A, 0x0000, 0x00FA,
0x0100, 0x0000, 0x0047, 0x212C, 0x002A, 0x0000, 0x012C, 0x0100,
0x0000, 0x0047, 0x212C, 0x002A, 0x0000, 0x015E, 0x0100, 0x0000,
0x0047, 0x212C, 0x002A, 0x0000, 0x0190, 0x0100, 0x0000, 0x0048,
0x212C, 0x002A, 0x0000, 0x0032, 0xFF00, 0x0000, 0x0048, 0x212C,
0x002A, 0x0000, 0x0064, 0x0100, 0x0000, 0x0048, 0x212C, 0x002A,
0x0000, 0x0096, 0x0100, 0x0000, 0x0048, 0x212C, 0x002A, 0x0000,
0x00C8, 0x0100, 0x0000, 0x0048, 0x212C, 0x002A, 0x0000, 0x00FA,
0x0100, 0x0000, 0x0048, 0x212C, 0x002A, 0x0000, 0x012C, 0x0100,
0x0000, 0x0048, 0x212C, 0x002A, 0x0000, 0x015E, 0x0100, 0x0000,
0x0048, 0x212C, 0x002A, 0x0000, 0x0190, 0x0100, 0x0000, 0x0049,
0x212C, 0x002A, 0x0000, 0x0032, 0xFF00, 0x0000, 0x0049, 0x212C,
0x002A, 0x0000, 0x0064, 0x0100, 0x0000, 0x0049, 0x212C, 0x002A,
0x0000, 0x0096, 0x0100, 0x0000, 0x0049, 0x212C, 0x002A, 0x0000,
0x00C8, 0x0100, 0x0000, 0x0049, 0x212C, 0x002A, 0x0000, 0x00FA,
0x0100, 0x0000, 0x0049, 0x212C, 0x002A, 0x0000, 0x012C, 0x0100,
0x0000, 0x0049, 0x212C, 0x002A, 0x0000, 0x015E, 0x0100, 0x0000,
0x0049, 0x212C, 0x002A, 0x0000, 0x0190, 0x0100, 0x0000, 0x004A,
0x212C, 0x002A, 0x0000, 0x0032, 0xFF00, 0x0000, 0x004A, 0x212C,
0x002A, 0x0000, 0x0064, 0x0100, 0x0000, 0x004A, 0x212C, 0x002A,
0x0000, 0x0096, 0x0100, 0x0000, 0x004A, 0x212C, 0x002A, 0x0000,
0x00C8, 0x0100, 0x0000, 0x004A, 0x212C, 0x002A, 0x0000, 0x00FA,
0x0100, 0x0000, 0x004A, 0x212C, 0x002A, 0x0000, 0x012C, 0x0100,
0x0000, 0x004A, 0x212C, 0x002A, 0x0000, 0x015E, 0x0100, 0x0000,
0x004A, 0x212C, 0x002A, 0x0000, 0x0190, 0x0100, 0x0000, 0x0058,
0x212C, 0x002A, 0x0000, 0x0320, 0xF000, 0x0000, 0x0059, 0x212C,
0x002A, 0x0000, 0x0320, 0xF000, 0x0000, 0x005A, 0x212C, 0x002A,
0x0000, 0x0320, 0xF000, 0x0000, 0x005B, 0x212C, 0x002A, 0x0000,
0x0320, 0x0100, 0x0000, 0x005C, 0x212C, 0x002A, 0x0000, 0x0320,
0x0100, 0x0000, 0x005D, 0x212C, 0x002A, 0x0000, 0x0320, 0x0100,
0x0000, 0x005E, 0x212C, 0x002A, 0x0000, 0x0320, 0x0100, 0x0000,
0x005F, 0x212C, 0x002A, 0x0000, 0x0320, 0x0100, 0x0000, 0x0060,
0x212C, 0x002A, 0x0000, 0x0190, 0xFF00, 0x0000, 0x0061, 0x212C,
0x002A, 0x0000, 0x0190, 0xFF00, 0x0000, 0x0062, 0x212C, 0x002A,
0x0000, 0x0190, 0xFF00, 0x0000, 0x0063, 0x212C, 0x002A, 0x0000,
0x0190, 0x0100, 0x0000, 0x0064, 0x212C, 0x002A, 0x0000, 0x0190,
0x0100, 0x0000, 0x0065, 0x212C, 0x002A, 0x0000, 0x0190, 0x0100,
0x0000, 0x0066, 0x212C, 0x002A, 0x0000, 0x0190, 0x0100, 0x0000,
0x0067, 0x212C, 0x002A, 0x0000, 0x0190, 0x0100, 0x0000, 0x0000,
0x212C, 0x002A, 0x0000, 0x0050, 0x0100, 0x0000, 0x0000, 0x212C,
0x002A, 0x0000, 0x008C, 0x0100, 0x0000, 0x0000, 0x212C, 0x002A,
0x0000, 0x00C8, 0x0100, 0x0000, 0x0000, 0x212C, 0x002A, 0x0000,
0x0118, 0x0100, 0x0000, 0x0000, 0x212C, 0x002A, 0x0000, 0x0168,
0x0100, 0x0000, 0x0000, 0x212C, 0x002A, 0x0000, 0x01B8, 0x0100,
0x0000, 0x0000, 0x212C, 0x002A, 0x0000, 0x0208, 0x0100, 0x0000,
0x0000, 0x212C, 0x002A, 0x0000, 0x0258, 0x0100, 0x0000, 0x0000,
0x212C, 0x002A, 0x0000, 0x0032, 0x0100, 0x0000, 0x0000, 0x212C,
0x002A, 0x0000, 0x0064, 0x0100, 0x0000, 0x0069, 0x212C, 0x002A,
0x0000, 0x003C, 0xFF00, 0x0000, 0x003C, 0x212C, 0x002A, 0x0000,
0x0064, 0xFF00, 0x0000, 0x0068, 0x212C, 0x002A, 0x0000, 0x0064,
0xFF00, 0x0000, 0x0000, 0x212C, 0x002A, 0x0000, 0x00FA, 0x0100,
0x0000, 0x0000, 0x212C, 0x002A, 0x0000, 0x0190, 0x0100, 0x0000,
0x0000, 0x212C, 0x002A, 0x0000, 0x0100, 0x0100, 0x0000, 0x006E,
0x212C, 0x002A, 0x0000, 0x0100, 0x0100, 0x0000, 0x0071, 0x212C,
0x002A, 0x0000, 0x0100, 0x0100, 0x0000, 0x0074, 0x212C, 0x002A,
0x0000, 0x003C, 0xFF00, 0x0000, 0x0000, 0x212C, 0x002A, 0x0000,
0x0100, 0x0100, 0x0000, 0x0000, 0x212C, 0x002A, 0x0000, 0x0100,
0x0100, 0x0000, 0x0079, 0x212C, 0x002A, 0x0000, 0x00F0, 0x0100,
0x0000, 0x007C, 0x212C, 0x002A, 0x0000, 0x05DC, 0x0100, 0x0000,
0x0000, 0x212C, 0x002A, 0x0000, 0x012C, 0x0100, 0x0000, 0x0090,
0x212C, 0x002A, 0x0000, 0x0096, 0xFF03, 0x0000, 0x0091, 0x212C,
0x002A, 0x0000, 0x0096, 0xFF00, 0x0000, 0x0092, 0x212C, 0x002A,
0x0000, 0x0096, 0xFF00, 0x0000, 0x0093, 0x212C, 0x002A, 0x0000,
0x0096, 0xFF00, 0x0000, 0x0094, 0x212C, 0x002A, 0x0000, 0x0096,
0xFF00, 0x0000, 0x0095, 0x212C, 0x002A, 0x0000, 0x0096, 0xFF00,
0x0000, 0x0096, 0x212C, 0x002A, 0x0000, 0x0096, 0xFF00, 0x0000,
0x0097, 0x212C, 0x002A, 0x0000, 0x0032, 0xFF03, 0x0000, 0x0084,
0x212C, 0x002A, 0x0000, 0x00FA, 0x0100, 0x0000, 0x0087, 0x212C,
0x002A, 0x0000, 0x00FA, 0x0100, 0x0000, 0x008A, 0x212C, 0x002A,
0x0000, 0x00FA, 0x0100, 0x0000, 0x009E, 0x212C, 0x002A, 0x0000,
0x007D, 0x0100, 0x0000, 0x008D, 0x212C, 0x002A, 0x0000, 0x00FA,
0x0100, 0x0000, 0x009F, 0x212C, 0x002A, 0x0000, 0x00FA, 0x0100,
0x0000, 0x00A8, 0x212C, 0x002A, 0x0000, 0x01F4, 0x0100, 0x0000,
0x00A8, 0x212C, 0x002A, 0x0000, 0x01F4, 0x0103, 0x0000, 0x00A8,
0x212C, 0x002A, 0x0000, 0x01F4, 0x0100, 0x0000, 0x00B2, 0x212C,
0x002A, 0x0000, 0x0320, 0x0400, 0x0000, 0x00B3, 0x212C, 0x002A,
0x0000, 0x0320, 0x0400, 0x0000, 0x004D, 0x212C, 0x002A, 0x0000,
0x0032, 0xFF00, 0x0000, 0x004D, 0x212C, 0x002A, 0x0000, 0x0096,
0x0100, 0x0000, 0x004D, 0x212C, 0x002A, 0x0000, 0x012C, 0x0100,
0x0000, 0x004D, 0x212C, 0x002A, 0x0000, 0x01C2, 0x0100, 0x0000,
0x004D, 0x212C, 0x002A, 0x0000, 0x0258, 0x0100, 0x0000, 0x004D,
0x212C, 0x002A, 0x0000, 0x02BC, 0x0100, 0x0000, 0x004D, 0x212C,
0x002A, 0x0000, 0x0320, 0x0100, 0x0000, 0x004D, 0x212C, 0x002A,
0x0000, 0x03B6, 0x0100, 0x0000, 0x0000, 0x212C, 0x002A, 0x0000,
0x00FA, 0x0100, 0x0000, 0x00A9, 0x212C, 0x002A, 0x0000, 0x00FA,
0x0100, 0x0000, 0x0098, 0x212C, 0x002A, 0x0000, 0x0096, 0x0100,
0x0000, 0x009B, 0x212C, 0x002A, 0x0000, 0x00C8, 0xFF00, 0x0000,
0x0000, 0x212C, 0x002A, 0x0000, 0x00FA, 0x0100, 0x0000, 0x00B4,
0x212C, 0x002A, 0x0000, 0x00FA, 0xFF00, 0x0000, 0x00B7, 0x212C,
0x002A, 0x0000, 0x00FA, 0xFF00, 0x0000, 0x0000, 0x212C, 0x002A,
0x0000, 0x00FA, 0x0100, 0x0000, 0x00BA, 0x212C, 0x002A, 0x0000,
0x012C, 0xFF00, 0x0000, 0x00C5, 0x212C, 0x002A, 0x0000, 0x00A0,
0xFF00, 0x0000, 0x0000, 0x212C, 0x002A, 0x0000, 0x00FA, 0x0100,
0x0000, 0x0000, 0x212C, 0x002A, 0x0000, 0x00FA, 0x0100, 0x0000,
0x0000, 0x212C, 0x002A, 0x0000, 0x00FA, 0x0100, 0x0000, 0x0000,
0x212C, 0x002A, 0x0000, 0x00FA, 0x0100, 0x0000, 0x0000, 0x212C,
0x002A, 0x0000, 0x00FA, 0x0100, 0x0000, 0x0000, 0x212C, 0x002A,
0x0000, 0x00FA, 0x0100, 0x0000, 0x0000, 0x212C, 0x002A, 0x0000,
0x00FA, 0x0100, 0x0000, 0x0000, 0x212C, 0x002A, 0x0000, 0x00FA,
0x0100, 0x0000, 0x0000, 0x212C, 0x002A, 0x0000, 0x00FA, 0x0100,
0x0000, 0x0000, 0x212C, 0x002A, 0x0000, 0x00FA, 0x0100, 0x0000,
0x0000, 0x212C, 0x002A, 0x0000, 0x00FA, 0x0100, 0x0000, 0x0000,
0x212C, 0x002A, 0x0000, 0x00FA, 0x0100, 0x0000, 0x0000, 0x212C,
0x002A, 0x0000, 0x00FA, 0x0100, 0x0000, 0x0000, 0x212C, 0x002A,
0x0000, 0x00FA, 0x0100, 0x0000, 0x0000, 0x212C, 0x002A, 0x0000,
0x00FA, 0x0100, 0x0000, 0x0000, 0x212C, 0x002A, 0x0000, 0x00FA,
0x0100, 0x0000, 0x0000, 0x212C, 0x002A, 0x0000, 0x00FA, 0x0100,
0x0000, 0x0000, 0x212C, 0x002A, 0x0000, 0x00FA, 0x0100, 0x0000,
0x0000, 0x212C, 0x002A, 0x0000, 0x00FA, 0x0100, 0x0000, 0x0000,
0x212C, 0x002A, 0x0000, 0x00FA, 0x0100, 0x0000, 0x0000, 0x212C,
0x002A, 0x0000, 0x00FA, 0x0100, 0x0000, 0x0000, 0x212C, 0x002A,
0x0000, 0x00FA, 0x0100, 0x0000, 0x0000, 0x212C, 0x002A, 0x0000,
0x00FA, 0x0100, 0x0000, 0x0000, 0x212C, 0x002A, 0x0000, 0x00FA,
0x0100, 0x0000, 0x00C6, 0x212C, 0x002A, 0x0000, 0x0190, 0x0100,
0x0000, 0x00C7, 0x212C, 0x002A, 0x0000, 0x012C, 0xFF00, 0x0000,
0x00CA, 0x212C, 0x002A, 0x0000, 0x00FA, 0x0100, 0x0000, 0x00D3,
0x212C, 0x002A, 0x0000, 0x00C8, 0xFF00, 0x0000, 0x00F3, 0x212C,
0x002A, 0x0000, 0x00C8, 0xFF00, 0x0000, 0x00CB, 0x212C, 0x002A,
0x0000, 0x00C8, 0x0100, 0x0000, 0x00FB, 0x212C, 0x002A, 0x0000,
0x00C8, 0x0100, 0x0000, 0x00EB, 0x212C, 0x002A, 0x0000, 0x00C8,
0x0100, 0x0000, 0x00E3, 0x212C, 0x002A, 0x0000, 0x00C8, 0x0100,
0x0000, 0x00DB, 0x212C, 0x002A, 0x0000, 0x00C8, 0x0100, 0x0000,
0x0103, 0x212C, 0x002A, 0x0000, 0x004B, 0xFF00, 0x0000, 0x0104,
0x212C, 0x002A, 0x0000, 0x0096, 0x0100, 0x0000, 0x0105, 0x212C,
0x002A, 0x0000, 0x0096, 0x0100, 0x0000, 0x0000, 0x212C, 0x002A,
0x0000, 0x0096, 0x0100, 0x0000, 0x0106, 0x212C, 0x002A, 0x0000,
0x0096, 0x0100, 0x0000, 0x0107, 0x212C, 0x002A, 0x0000, 0x010E,
0x0100, 0x0000, 0x010F, 0x212C, 0x002A, 0x0000, 0x02BC, 0x0100,
0x0000, 0x0117, 0x212C, 0x002A, 0x0000, 0x00C8, 0x0100, 0x0000,
0x011F, 0x212C, 0x002A, 0x0000, 0x00C8, 0x0100, 0x0000, 0x0127,
0x212C, 0x002A, 0x0000, 0x0230, 0x0100, 0x0000, 0x012F, 0x212C,
0x002A, 0x0000, 0x0352, 0x0100, 0x0000, 0x0137, 0x212C, 0x002A,
0x0000, 0x0258, 0x0100, 0x0000, 0x013F, 0x212C, 0x002A, 0x0000,
0x003C, 0x0100, 0x0000, 0x0147, 0x212C, 0x002A, 0x0000, 0x0046,
0x0102, 0x0000, 0x0147, 0x212C, 0x002A, 0x0000, 0x0050, 0x0102,
0x0000, 0x0147, 0x212C, 0x002A, 0x0000, 0x005A, 0x0102, 0x0000,
0x0147, 0x212C, 0x002A, 0x0000, 0x0064, 0x0102, 0x0000, 0x0147,
0x212C, 0x002A, 0x0000, 0x006E, 0x0102, 0x0000, 0x0147, 0x212C,
0x002A, 0x0000, 0x0078, 0x0102, 0x0000, 0x0147, 0x212C, 0x002A,
0x0000, 0x0082, 0x0102, 0x0000, 0x0147, 0x212C, 0x002A, 0x0000,
0x0096, 0x0102, 0x0000, 0x0147, 0x212C, 0x002A, 0x0000, 0x00B4,
0x0102, 0x0000, 0x0147, 0x212C, 0x002A, 0x0000, 0x00DC, 0x0102,
0x0000, 0x0147, 0x212C, 0x002A, 0x0000, 0x0118, 0x0102, 0x0000,
0x0147, 0x212C, 0x002A, 0x0000, 0x0168, 0x0102, 0x0000, 0x0148,
0x212C, 0x002A, 0x0000, 0x00FA, 0x0100, 0x0000, 0x0150, 0x212C,
0x002A, 0x0000, 0x00FA, 0x0100, 0x0000, 0x0158, 0x212C, 0x002A,
0x0000, 0x00FA, 0x0100, 0x0000, 0x0160, 0x212C, 0x002A, 0x0000,
0x00FA, 0x0100, 0x0000, 0x0168, 0x212C, 0x002A, 0x0000, 0x00FA,
0x0100, 0x0000, 0x0170, 0x212C, 0x002A, 0x0000, 0x00FA, 0x0100,
0x0000, 0x0178, 0x212C, 0x002A, 0x0000, 0x00FA, 0x0100, 0x0000,
0x0180, 0x212C, 0x002A, 0x0000, 0x0096, 0x0100, 0x0000, 0x0188,
0x212C, 0x002A, 0x0000, 0x0078, 0x0100, 0x0000, 0x0189, 0x212C,
0x002A, 0x0000, 0x003C, 0x0100, 0x0000, 0x018A, 0x212C, 0x002A,
0x0000, 0x0320, 0x0100, 0x0000, 0x0192, 0x212C, 0x002A, 0x0000,
0x0104, 0x0100, 0x0000, 0x019A, 0x212C, 0x002A, 0x0000, 0x0078,
0x0100, 0x0000, 0x019B, 0x212C, 0x002A, 0x0000, 0x0140, 0x0100,
0x0000, 0x01A3, 0x212C, 0x002A, 0x0000, 0x00A0, 0x0100, 0x0000,
0x01A4, 0x212C, 0x002A, 0x0000, 0x0078, 0x0100, 0x0000, 0x01A5,
0x212C, 0x002A, 0x0000, 0x0078, 0x0100, 0x0000, 0x01A6, 0x212C,
0x002A, 0x0000, 0x00C8, 0x0100, 0x0000, 0x01A7, 0x212C, 0x002A,
0x0000, 0x00C8, 0x0100, 0x0000, 0x01A8, 0x212C, 0x002A, 0x0000,
0x0064, 0x0100, 0x0000, 0x01A8, 0x212C, 0x002A, 0x0000, 0x0096,
0x0100, 0x0000, 0x01A8, 0x212C, 0x002A, 0x0000, 0x00C8, 0x0100,
0x0000, 0x01A8, 0x212C, 0x002A, 0x0000, 0x00FA, 0x0100, 0x0000,
0x01A9, 0x212C, 0x002A, 0x0000, 0x00AF, 0x0100, 0x0000, 0x01A9,
0x212C, 0x002A, 0x0000, 0x0106, 0x0100, 0x0000, 0x01A9, 0x212C,
0x002A, 0x0000, 0x015E, 0x0100, 0x0000, 0x01A9, 0x212C, 0x002A,
0x0000, 0x01B5, 0x0100, 0x0000, 0x01AA, 0x212C, 0x002A, 0x0000,
0x003C, 0xFF00, 0x0000, 0x01AA, 0x212C, 0x002A, 0x0000, 0x0064,
0xFF00, 0x0000, 0x01AA, 0x212C, 0x002A, 0x0000, 0x008C, 0xFF00,
0x0000, 0x01B5, 0x212C, 0x002A, 0x0000, 0x01C2, 0x0100, 0x0000,
0x01BD, 0x212C, 0x002A, 0x0000, 0x01C2, 0x0100, 0x0000, 0x01C5,
0x212C, 0x002A, 0x0000, 0x0320, 0x0100, 0x0000, 0x01CD, 0x212C,
0x002A, 0x0000, 0x02BC, 0x0100, 0x0000, 0x01CE, 0x212C, 0x002A,
0x0000, 0x03E8, 0x0100, 0x0000, 0x01CF, 0x212C, 0x002A, 0x0000,
0x0064, 0x0100, 0x0000, 0x01D0, 0x212C, 0x002A, 0x0000, 0x04B0,
0x0100, 0x0000, 0x01D8, 0x212C, 0x002A, 0x0000, 0x04B0, 0x0100,
0x0000, 0x01E0, 0x212C, 0x002A, 0x0000, 0x04B0, 0x0100, 0x0000,
0x01E8, 0x212C, 0x002A, 0x0000, 0x04B0, 0x0100, 0x0000, 0x01F0,
0x212C, 0x002A, 0x0000, 0x04B0, 0x0100, 0x0000, 0x0000, 0x0000,
0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xFF00, 0x0003, 0x00FA };

void sub_70BF0_close_tmaps()//251bf0
{
	//int result; // eax

	if (int32_t_DB740_tmaps00file != NULL)
	{
		sub_98882_close(int32_t_DB740_tmaps00file);
		int32_t_DB740_tmaps00file = NULL;
	}
	if (int32_t_DB744_tmaps10file != NULL)
	{
		sub_98882_close(int32_t_DB744_tmaps10file);
		int32_t_DB744_tmaps10file = NULL;
	}
	if (int32_t_DB748_tmaps20file != NULL)
	{
		sub_98882_close(int32_t_DB748_tmaps20file);
		int32_t_DB748_tmaps20file = NULL;
	}
	int32_t_DB73C_tmapsfile = NULL;
	//return result;
}

uint8_t int32_t_180628b_screen_buffer[640*480];
void sub_71410_process_tmaps()//252410
{
	uint16_t* v0; // esi
	uint8_t* v1; // ebx
	uint16_t v2; // di

	sub_70A60_open_tmaps();
	v0 = int16_t_D951C;
	v1 = int32_t_180628b_screen_buffer;
	while (v0[3] || v0[4])
	{
		v2 = *v0;
		memset((void*)v1, 0, *(uint32_t*)& TMAPS00TAB_BEGIN_BUFFER[10 * (*v0 + 1) + 4] - *(uint32_t*)& TMAPS00TAB_BEGIN_BUFFER[10 * *v0 + 4]);
		if (sub_70C60_decompress_tmap(v2, v1) == -1)
		{
			*(int16_t*)(v1 + 2) = 255;
			*(int16_t*)(v1 + 4) = 255;
			*(int8_t*)(v1 + 1) = 1;
		}
		if (!*(int16_t*)(v1 + 4) || !*(int16_t*)(v1 + 2))
		{
			*(int16_t*)(v1 + 2) = 255;
			*(int16_t*)(v1 + 4) = 255;
			*(int8_t*)(v1 + 1) = 1;
		}
		if (v0[3])
		{
			if (!v0[4])
				v0[4] = *(uint16_t*)(v1 + 4) * v0[3] / *(uint16_t*)(v1 + 2);
		}
		else
		{
			v0[3] = *(uint16_t*)(v1 + 2) * v0[4] / *(uint16_t*)(v1 + 4);
		}
		v0 += 7;
		*((int8_t*)v0 - 2) = *(int8_t*)(v1 + 1);
	}
	sub_70BF0_close_tmaps();
}

void main2()
{
	uint16_t v0; // bx
	//int16_t result; // ax

	v0 = 0;
	do
	{
		//result = v0;
		//if (int8_t_F5340[v0])
			/*result = */sub_70F50(v0);
		v0++;
	} while (v0 < 0x1F8u);
    std::cout << "Hello World!\n"; 
}
typedef struct {
	char path[512];
	uint8_t** var28_begin_buffer;//1C // asi buffer
	uint8_t** var32_end_buffer;//20 // asi buffer
	uint32_t var36_size_buffer;//24 //asi file size
	uint32_t var40_alloc_type;//28
} Pathstruct;
Pathstruct pstrx = { "c:/prenos/Magic2/mc2-orig/netherw/cdata/tmaps0-0.tab",&TMAPS00TAB_BEGIN_BUFFER,NULL,1389610,NULL };

uint8_t* sub_9A2F5(Pathstruct path)//27B2f5
{
	uint8_t* result; // eax
	//2bac30
	result = *path.var28_begin_buffer;//fix it 2bac30
	//result = 0;//fix it
	if (result)
	{
		//sub_83E80_freemem4(*path.var28_begin_buffer);
		result = *path.var28_begin_buffer;
		*result = 0;
	}
	return result;
}

void* sub_83D70_malloc1(int a1)//264d70
{
	return malloc(a1);
}
void* sub_83CD0_malloc2(size_t a1)//264cd0
{
	return malloc(a1);
}
int32_t myfseek(FILE* filedesc, int32_t position, char type) {
	return fseek(filedesc, position, type);
};

long myftell(FILE* decriptor) {
	return ftell(decriptor);
};
long x_filelength(FILE* decriptor) {
	long size;
	myfseek(decriptor, 0, SEEK_END); // seek to end of file
	size = myftell(decriptor); // get current file pointer
	myfseek(decriptor, 0, SEEK_SET); // seek back to beginning of file
	return size;
};
int32_t sub_AB9E1_get_file_unpack_size(char* a1)//28c9e1
{
	uint8_t v2[10]; // [esp+0h] [ebp-1Ch]
	unsigned __int8 v3; // [esp+4h] [ebp-18h]
	unsigned __int8 v4; // [esp+5h] [ebp-17h]
	unsigned __int8 v5; // [esp+6h] [ebp-16h]
	unsigned __int8 v6; // [esp+7h] [ebp-15h]
	//char v7; // [esp+8h] [ebp-14h]
	//char v8; // [esp+9h] [ebp-13h]
	char v9; // [esp+Ah] [ebp-12h]
	char v10; // [esp+Bh] [ebp-11h]
	//char v11; // [esp+Ch] [ebp-10h]
	int ret_size; // [esp+14h] [ebp-8h]
	FILE* file; // [esp+18h] [ebp-4h]

	//fix it
	v3 = 0;
	v4 = 0;
	v5 = 0;
	v6 = 0;
	v9 = 0;
	v10 = 0;
	//fix it

	ret_size = -1;
	//v7 = 'R';
	//v8 = 'N';
	//v9 = 'C';
	//v10 = 1;
	//v11 = 0;
	file = sub_98817_open(a1, 512);
	if (file == NULL)
		return -1;
	sub_988A7_read(file, v2, 8);
	if (!strncmp((const char*)v2, (const char*)"RNC\1", 4))
	{
		ret_size = v2[4] << 8;//reverse size in rnc format
		ret_size += v2[5];
		ret_size <<= 8;
		ret_size += v2[6];
		ret_size <<= 8;
		ret_size += v2[7];
	}
	else
	{
		ret_size = x_filelength(file);
	}
	sub_98882_close(file);
	return ret_size;
}
int sub_53E60_readfile_and_decompress(const char* path, uint8_t** a2)//234E60
{
	int32_t result; // eax
	FILE* file; // ebx
	uint32_t v4; // esi
	file = sub_98817_open((char*)path, 0x200);//234E72 - 279817
	result = (int32_t)file;
	if (result != NULL)
	{
		v4 = x_filelength(file);//234E82 - 2798DA
		sub_988A7_read(file, *a2, v4);//234E8F - 2798A7
		sub_98882_close(file);//234E98 - 279882
		result = (int32_t)sub_9894C_decompress(*a2, *a2);//234ea2 - 27994c
		if (result >= 0)
		{
			if (!result)
				result = v4;
		}
		else
		{
			printf("ERROR decompressing %s\n");
			result = -2;
		}
	}
	return result;
}
int32_t sub_9A32D_malloc_open_unpack(Pathstruct path)//27B32d
{
	//int v1; // edx
	//int *v2; // eax
	//void* v3; // edx
	//int *v4; // eax
	//void* (*v6)(int); // [esp+0h] [ebp-8h]

	//sub_85070();
	/*if (path.var40_alloc_type & 1 )
	  v6 = sub_83D70_malloc1;
	else
	  v6 = sub_83CD0_malloc2;*/
	sub_9A2F5(path);
	if (path.path[0] == 0x2A)//fix
	{
		if (path.var40_alloc_type & 1)
		{
			*(path.var28_begin_buffer) = (uint8_t*)sub_83D70_malloc1(path.var36_size_buffer);
			memset(*(path.var28_begin_buffer), 0, path.var36_size_buffer);
		}
		else
		{
			*(path.var28_begin_buffer) = (uint8_t*)sub_83CD0_malloc2(path.var36_size_buffer);
			memset(*(path.var28_begin_buffer), 0, path.var36_size_buffer);
		}
		//v2 = *(int *)(path.var28_begin_buffer);
		//*v2 = v1;
		if (!(*(path.var28_begin_buffer)))
			return 0;
	}
	else
	{
		path.var36_size_buffer = (int)sub_AB9E1_get_file_unpack_size(path.path);
		if (path.var36_size_buffer <= 0)
			return 0;
		if (path.var40_alloc_type & 1)
		{
			*(path.var28_begin_buffer) = (uint8_t*)sub_83D70_malloc1(path.var36_size_buffer);//asi init a malloc bufferu
			memset(*(path.var28_begin_buffer), 0, path.var36_size_buffer);
		}
		else
		{
			*(path.var28_begin_buffer) = (uint8_t*)sub_83CD0_malloc2(path.var36_size_buffer);//asi init a malloc bufferu
			memset(*(path.var28_begin_buffer), 0, path.var36_size_buffer);
		}
		//v4 = *(int **)path.var28_begin_buffer;
		//*v4 = v3;
		if (!(*(path.var28_begin_buffer)))
			return -1;
		if (sub_53E60_readfile_and_decompress(path.path, path.var28_begin_buffer) != path.var36_size_buffer)
		{
			path.var28_begin_buffer = 0;
			path.var32_end_buffer = 0;
			path.var36_size_buffer = 0;
			return 0;
		}
	}
	if (path.var32_end_buffer)
		(*path.var32_end_buffer) = (*path.var28_begin_buffer) + path.var36_size_buffer;//fix ma byt 1
	return 1;
}

int main() {
	//uint8_t* begin;
	//uint8_t* end;
	//pstrx.var28_begin_buffer = &begin;
	//pstrx.var32_end_buffer = &end;
	sub_9A32D_malloc_open_unpack(pstrx);
	sub_71410_process_tmaps();
	uint16_t v0; // bx
	//int16_t result; // ax

	v0 = 0;
	do
	{
		//result = v0;
		//if (int8_t_F5340[v0])
		/*result = */sub_70F50(v0);
		v0++;
	} while (v0 < 0x1F8u);
	std::cout << "Hello World!\n";
}

// Spuštění programu: Ctrl+F5 nebo nabídka Ladit > Spustit bez ladění
// Ladění programu: F5 nebo nabídka Ladit > Spustit ladění

// Tipy pro zahájení práce:
//   1. K přidání nebo správě souborů použijte okno Průzkumník řešení.
//   2. Pro připojení ke správě zdrojového kódu použijte okno Team Explorer.
//   3. K zobrazení výstupu sestavení a dalších zpráv použijte okno Výstup.
//   4. K zobrazení chyb použijte okno Seznam chyb.
//   5. Pokud chcete vytvořit nové soubory kódu, přejděte na Projekt > Přidat novou položku. Pokud chcete přidat do projektu existující soubory kódu, přejděte na Projekt > Přidat existující položku.
//   6. Pokud budete chtít v budoucnu znovu otevřít tento projekt, přejděte na Soubor > Otevřít > Projekt a vyberte příslušný soubor .sln.
